Designing the encoding and finite automaton to recognize self-avoiding walks was an iterative process. Our concept of state and alphabet underwent numerous revisions as we tested and re-tested each idea. The result is an algorithm, the transition function $\delta$ outlined in Section~\ref{sec:overview-delta}, that we believe is sound and complete. At each step of the algorithm, we reason that each case discussed is accounted for, and that the complete algorithm accounts for all possible inputs. In addition, we tested the automaton on more than 50 inputs. While the data provide strong evidence that our algorithm is good, this research would be more complete with a formal proof of the algorithm's correctness.

The DFA produced by this algorithm consists of 20 states, and 136 transitions to non-dead states. Using the tools available in PADS~\cite{eppstein:automata:www:2013}, we found that the minimized DFA consists of only 17 states and 126 transitions to non-dead transitions. In fact, evaluation of the minimal DFA reveals that we could simplify our concept of state (presented in Section~\ref{sec:overview-state}) slightly by removing some ``double-ended'' states that were apparently redundant. It is encouraging that we were able to develop a DFA that is so close to minimal without using minimization tools. Furthermore, provided that the algorithm is correct, this slight revision to our concept of state would result in an ``optimal'' algorithm for the transition function in the sense that it would produce a minimal DFA. 

It would be straightforward to use this DFA constrction to count the number of self-avoiding walks in a $3\times n$ square lattice. Counting the number of walks of a given length $k$ is less straightforward, because each input symbol may add a variable number of segments to a valid walk. However, considering the ``weight'' of each input symbol in terms of the length it adds to the self-avoiding walk is likely a good place to start.
